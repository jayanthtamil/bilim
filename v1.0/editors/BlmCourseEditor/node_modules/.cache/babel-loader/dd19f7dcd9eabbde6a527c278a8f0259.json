{"ast":null,"code":"import i18next from \"i18next\";\nimport { MIMEType } from \"editor-constants\";\nimport { MediaTrackCue } from \"types\";\nimport { formatFullTime, parseWebVTT } from \"utils\";\nconst Image = [MIMEType.JPG, MIMEType.JPEG, MIMEType.PNG, MIMEType.GIF, MIMEType.SVG];\nconst Video = [MIMEType.MP4, MIMEType.WEBM];\nconst Zip = [MIMEType.ZIP, MIMEType.ZIP_COMPRESSED];\nconst JSON = [MIMEType.JSON];\nexport const isImage = type => {\n  return Image.indexOf(type) !== -1;\n};\nexport const isVideo = type => {\n  return Video.indexOf(type) !== -1;\n};\nexport const isAudio = type => {\n  return MIMEType.MPEG === type;\n};\nexport const isZip = type => {\n  return Zip.indexOf(type) !== -1;\n};\nexport const isJSON = type => {\n  return JSON.indexOf(type) !== -1;\n};\nexport const getFileName = name => {\n  return name.replace(/\\.[^/.]+$/, \"\");\n};\nexport const getFileExtension = name => {\n  const arr = name.split(\".\");\n  return arr.length > 1 ? arr.pop().toLowerCase() : \"\";\n};\nexport const getFileSize = bytes => {\n  return bytes / (1024 * 1024);\n};\nexport function createVTTFile(tracks) {\n  return tracks.reduce((str, track, index) => {\n    const {\n      startTime,\n      endTime,\n      text\n    } = track;\n    return str + `\\n\\n${formatFullTime(startTime)} --> ${formatFullTime(endTime)}\\n${text.replace(/(^[ \\t]*\\n)/gm, \"\")}`;\n  }, `WEBVTT`);\n}\nexport function createMediaCues(file) {\n  const result = parseWebVTT(file);\n\n  if (result.valid) {\n    return result.cues.map(item => {\n      const {\n        start,\n        end,\n        text\n      } = item;\n      return new MediaTrackCue(start, end, text);\n    });\n  } else {\n    console.error(result.errors);\n  }\n\n  return [];\n}\nexport function validateFile(file, extension) {\n  if (getFileSize(file.size) > 100) {\n    throw new Error(i18next.t(\"utils:alert.file_size\"));\n  } else if (extension) {\n    const newExtenstion = getFileExtension(file.name);\n\n    if (extension !== newExtenstion) {\n      throw new Error(i18next.t(\"utils:alert.file_type\"));\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/src/utils/editor/file.ts"],"names":["i18next","MIMEType","MediaTrackCue","formatFullTime","parseWebVTT","Image","JPG","JPEG","PNG","GIF","SVG","Video","MP4","WEBM","Zip","ZIP","ZIP_COMPRESSED","JSON","isImage","type","indexOf","isVideo","isAudio","MPEG","isZip","isJSON","getFileName","name","replace","getFileExtension","arr","split","length","pop","toLowerCase","getFileSize","bytes","createVTTFile","tracks","reduce","str","track","index","startTime","endTime","text","createMediaCues","file","result","valid","cues","map","item","start","end","console","error","errors","validateFile","extension","size","Error","t","newExtenstion"],"mappings":"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","sourcesContent":["import i18next from \"i18next\";\r\n\r\nimport { MIMEType } from \"editor-constants\";\r\nimport { MediaTrackCue } from \"types\";\r\nimport { formatFullTime, parseWebVTT } from \"utils\";\r\n\r\nconst Image = [MIMEType.JPG, MIMEType.JPEG, MIMEType.PNG, MIMEType.GIF, MIMEType.SVG];\r\nconst Video = [MIMEType.MP4, MIMEType.WEBM];\r\nconst Zip = [MIMEType.ZIP, MIMEType.ZIP_COMPRESSED];\r\nconst JSON = [MIMEType.JSON];\r\n\r\nexport const isImage = (type: MIMEType) => {\r\n  return Image.indexOf(type) !== -1;\r\n};\r\n\r\nexport const isVideo = (type: MIMEType) => {\r\n  return Video.indexOf(type) !== -1;\r\n};\r\n\r\nexport const isAudio = (type: MIMEType) => {\r\n  return MIMEType.MPEG === type;\r\n};\r\n\r\nexport const isZip = (type: MIMEType) => {\r\n  return Zip.indexOf(type) !== -1;\r\n};\r\n\r\nexport const isJSON = (type: MIMEType) => {\r\n  return JSON.indexOf(type) !== -1;\r\n};\r\n\r\nexport const getFileName = (name: string) => {\r\n  return name.replace(/\\.[^/.]+$/, \"\");\r\n};\r\n\r\nexport const getFileExtension = (name: string) => {\r\n  const arr = name.split(\".\");\r\n  return arr.length > 1 ? arr.pop()!.toLowerCase() : \"\";\r\n};\r\n\r\nexport const getFileSize = (bytes: number) => {\r\n  return bytes / (1024 * 1024);\r\n};\r\n\r\nexport function createVTTFile(tracks: MediaTrackCue[]) {\r\n  return tracks.reduce((str, track, index) => {\r\n    const { startTime, endTime, text } = track;\r\n\r\n    return (\r\n      str +\r\n      `\\n\\n${formatFullTime(startTime)} --> ${formatFullTime(endTime)}\\n${text.replace(\r\n        /(^[ \\t]*\\n)/gm,\r\n        \"\"\r\n      )}`\r\n    );\r\n  }, `WEBVTT`);\r\n}\r\n\r\nexport function createMediaCues(file: string) {\r\n  const result = parseWebVTT(file);\r\n\r\n  if (result.valid) {\r\n    return result.cues.map((item) => {\r\n      const { start, end, text } = item;\r\n\r\n      return new MediaTrackCue(start, end, text);\r\n    });\r\n  } else {\r\n    console.error(result.errors);\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\nexport function validateFile(file: File, extension?: string) {\r\n  if (getFileSize(file.size) > 100) {\r\n    throw new Error(i18next.t(\"utils:alert.file_size\"));\r\n  } else if (extension) {\r\n    const newExtenstion = getFileExtension(file.name);\r\n\r\n    if (extension !== newExtenstion) {\r\n      throw new Error(i18next.t(\"utils:alert.file_type\"));\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}