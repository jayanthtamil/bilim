{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n *\n * \n * @format\n * @oncall draft_js\n */\n\n\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar traverseInDepthOrder = function traverseInDepthOrder(blocks, fn) {\n  var stack = [].concat(blocks).reverse();\n\n  while (stack.length) {\n    var _block = stack.pop();\n\n    fn(_block);\n    var children = _block.children;\n    !Array.isArray(children) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid tree raw block') : invariant(false) : void 0;\n    stack = stack.concat([].concat(children.reverse()));\n  }\n};\n\nvar isListBlock = function isListBlock(block) {\n  if (!(block && block.type)) {\n    return false;\n  }\n\n  var type = block.type;\n  return type === 'unordered-list-item' || type === 'ordered-list-item';\n};\n\nvar addDepthToChildren = function addDepthToChildren(block) {\n  if (Array.isArray(block.children)) {\n    block.children = block.children.map(function (child) {\n      return child.type === block.type ? _objectSpread(_objectSpread({}, child), {}, {\n        depth: (block.depth || 0) + 1\n      }) : child;\n    });\n  }\n};\n/**\n * This adapter is intended to be be used as an adapter to draft tree data\n *\n * draft state <=====> draft tree state\n */\n\n\nvar DraftTreeAdapter = {\n  /**\n   * Converts from a tree raw state back to draft raw state\n   */\n  fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {\n    var blocks = draftTreeState.blocks;\n    var transformedBlocks = [];\n    !Array.isArray(blocks) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid raw state') : invariant(false) : void 0;\n\n    if (!Array.isArray(blocks) || !blocks.length) {\n      return draftTreeState;\n    }\n\n    traverseInDepthOrder(blocks, function (block) {\n      var newBlock = _objectSpread({}, block);\n\n      if (isListBlock(block)) {\n        newBlock.depth = newBlock.depth || 0;\n        addDepthToChildren(block); // if it's a non-leaf node, we don't do anything else\n\n        if (block.children != null && block.children.length > 0) {\n          return;\n        }\n      }\n\n      delete newBlock.children;\n      transformedBlocks.push(newBlock);\n    });\n    draftTreeState.blocks = transformedBlocks;\n    return _objectSpread(_objectSpread({}, draftTreeState), {}, {\n      blocks: transformedBlocks\n    });\n  },\n\n  /**\n   * Converts from draft raw state to tree draft state\n   */\n  fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {\n    var transformedBlocks = [];\n    var parentStack = [];\n    draftState.blocks.forEach(function (block) {\n      var isList = isListBlock(block);\n      var depth = block.depth || 0;\n\n      var treeBlock = _objectSpread(_objectSpread({}, block), {}, {\n        children: []\n      });\n\n      if (!isList) {\n        transformedBlocks.push(treeBlock);\n        return;\n      }\n\n      var lastParent = parentStack[0]; // block is non-nested & there are no nested blocks, directly push block\n\n      if (lastParent == null && depth === 0) {\n        transformedBlocks.push(treeBlock); // block is first nested block or previous nested block is at a lower level\n      } else if (lastParent == null || lastParent.depth < depth - 1) {\n        // create new parent block\n        var newParent = {\n          key: generateRandomKey(),\n          text: '',\n          depth: depth - 1,\n          type: block.type,\n          children: [],\n          entityRanges: [],\n          inlineStyleRanges: []\n        };\n        parentStack.unshift(newParent);\n\n        if (depth === 1) {\n          // add as a root-level block\n          transformedBlocks.push(newParent);\n        } else if (lastParent != null) {\n          // depth > 1 => also add as previous parent's child\n          lastParent.children.push(newParent);\n        }\n\n        newParent.children.push(treeBlock);\n      } else if (lastParent.depth === depth - 1) {\n        // add as child of last parent\n        lastParent.children.push(treeBlock);\n      } else {\n        // pop out parents at levels above this one from the parent stack\n        while (lastParent != null && lastParent.depth >= depth) {\n          parentStack.shift();\n          lastParent = parentStack[0];\n        }\n\n        if (depth > 0) {\n          lastParent.children.push(treeBlock);\n        } else {\n          transformedBlocks.push(treeBlock);\n        }\n      }\n    });\n    return _objectSpread(_objectSpread({}, draftState), {}, {\n      blocks: transformedBlocks\n    });\n  }\n};\nmodule.exports = DraftTreeAdapter;","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/node_modules/draft-js/lib/DraftTreeAdapter.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","generateRandomKey","require","invariant","traverseInDepthOrder","blocks","fn","stack","concat","reverse","_block","pop","children","Array","isArray","process","env","NODE_ENV","isListBlock","block","type","addDepthToChildren","map","child","depth","DraftTreeAdapter","fromRawTreeStateToRawState","draftTreeState","transformedBlocks","newBlock","fromRawStateToRawTreeState","draftState","parentStack","isList","treeBlock","lastParent","newParent","text","entityRanges","inlineStyleRanges","unshift","shift","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n *\n * \n * @format\n * @oncall draft_js\n */\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar traverseInDepthOrder = function traverseInDepthOrder(blocks, fn) {\n  var stack = [].concat(blocks).reverse();\n\n  while (stack.length) {\n    var _block = stack.pop();\n\n    fn(_block);\n    var children = _block.children;\n    !Array.isArray(children) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid tree raw block') : invariant(false) : void 0;\n    stack = stack.concat([].concat(children.reverse()));\n  }\n};\n\nvar isListBlock = function isListBlock(block) {\n  if (!(block && block.type)) {\n    return false;\n  }\n\n  var type = block.type;\n  return type === 'unordered-list-item' || type === 'ordered-list-item';\n};\n\nvar addDepthToChildren = function addDepthToChildren(block) {\n  if (Array.isArray(block.children)) {\n    block.children = block.children.map(function (child) {\n      return child.type === block.type ? _objectSpread(_objectSpread({}, child), {}, {\n        depth: (block.depth || 0) + 1\n      }) : child;\n    });\n  }\n};\n/**\n * This adapter is intended to be be used as an adapter to draft tree data\n *\n * draft state <=====> draft tree state\n */\n\n\nvar DraftTreeAdapter = {\n  /**\n   * Converts from a tree raw state back to draft raw state\n   */\n  fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {\n    var blocks = draftTreeState.blocks;\n    var transformedBlocks = [];\n    !Array.isArray(blocks) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid raw state') : invariant(false) : void 0;\n\n    if (!Array.isArray(blocks) || !blocks.length) {\n      return draftTreeState;\n    }\n\n    traverseInDepthOrder(blocks, function (block) {\n      var newBlock = _objectSpread({}, block);\n\n      if (isListBlock(block)) {\n        newBlock.depth = newBlock.depth || 0;\n        addDepthToChildren(block); // if it's a non-leaf node, we don't do anything else\n\n        if (block.children != null && block.children.length > 0) {\n          return;\n        }\n      }\n\n      delete newBlock.children;\n      transformedBlocks.push(newBlock);\n    });\n    draftTreeState.blocks = transformedBlocks;\n    return _objectSpread(_objectSpread({}, draftTreeState), {}, {\n      blocks: transformedBlocks\n    });\n  },\n\n  /**\n   * Converts from draft raw state to tree draft state\n   */\n  fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {\n    var transformedBlocks = [];\n    var parentStack = [];\n    draftState.blocks.forEach(function (block) {\n      var isList = isListBlock(block);\n      var depth = block.depth || 0;\n\n      var treeBlock = _objectSpread(_objectSpread({}, block), {}, {\n        children: []\n      });\n\n      if (!isList) {\n        transformedBlocks.push(treeBlock);\n        return;\n      }\n\n      var lastParent = parentStack[0]; // block is non-nested & there are no nested blocks, directly push block\n\n      if (lastParent == null && depth === 0) {\n        transformedBlocks.push(treeBlock); // block is first nested block or previous nested block is at a lower level\n      } else if (lastParent == null || lastParent.depth < depth - 1) {\n        // create new parent block\n        var newParent = {\n          key: generateRandomKey(),\n          text: '',\n          depth: depth - 1,\n          type: block.type,\n          children: [],\n          entityRanges: [],\n          inlineStyleRanges: []\n        };\n        parentStack.unshift(newParent);\n\n        if (depth === 1) {\n          // add as a root-level block\n          transformedBlocks.push(newParent);\n        } else if (lastParent != null) {\n          // depth > 1 => also add as previous parent's child\n          lastParent.children.push(newParent);\n        }\n\n        newParent.children.push(treeBlock);\n      } else if (lastParent.depth === depth - 1) {\n        // add as child of last parent\n        lastParent.children.push(treeBlock);\n      } else {\n        // pop out parents at levels above this one from the parent stack\n        while (lastParent != null && lastParent.depth >= depth) {\n          parentStack.shift();\n          lastParent = parentStack[0];\n        }\n\n        if (depth > 0) {\n          lastParent.children.push(treeBlock);\n        } else {\n          transformedBlocks.push(treeBlock);\n        }\n      }\n    });\n    return _objectSpread(_objectSpread({}, draftState), {}, {\n      blocks: transformedBlocks\n    });\n  }\n};\nmodule.exports = DraftTreeAdapter;"]},"metadata":{},"sourceType":"script"}