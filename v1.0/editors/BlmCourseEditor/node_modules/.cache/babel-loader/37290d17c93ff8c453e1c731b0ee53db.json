{"ast":null,"code":"import { EditorState, Modifier } from \"draft-js\";\nimport { stateFromHTML } from \"draft-js-import-html\";\nimport { stateToHTML } from \"draft-js-export-html\";\nimport { Map, OrderedSet } from \"immutable\";\nimport { decorator, stateConfig, htmlConfig } from \"./config\";\nimport { INLINE_STYLE_BG_COLOR_PREFIX, INLINE_STYLE_BOLD, INLINE_STYLE_COLOR_PREFIX, INLINE_STYLE_FONT_PREFIX, INLINE_STYLE_SIZE_PREFIX, INLINE_STYLE_HIGHLIGHT, INLINE_STYLE_ITALIC, INLINE_STYLE_UNDERLINE } from \"editor-constants\";\nexport const createEditorState = html => {\n  const content = stateFromHTML(html, stateConfig);\n  const newContent = serializeContent(content);\n  return EditorState.createWithContent(newContent, decorator);\n};\nexport const createEditorHTML = state => {\n  const newState = removeInlineStyle(state, INLINE_STYLE_HIGHLIGHT);\n  const content = newState.getCurrentContent();\n  const html = content.hasText() ? stateToHTML(content, htmlConfig) : \"\";\n  return decodeHTML(html);\n};\n\nconst decodeHTML = str => {\n  return str.replace(/&nbsp;/g, \"\\xA0\");\n}; //https://github.com/sstur/draft-js-utils/pull/155/checks\n//This function serialize multiple nested inline array into single inline style array\n//After above PR is approved and include in release we can remove this function.\n//This function avoid that we need to check inline style are single or nested array in other utill functions\n\n\nconst serializeContent = contentState => {\n  const blockMap = contentState.getBlockMap();\n  const newBlockMap = blockMap.map(block => {\n    let list = block.getCharacterList();\n    list = list.map(char => {\n      return serializeStyle(char);\n    });\n    return block.set(\"characterList\", list);\n  });\n  return contentState.merge({\n    blockMap: blockMap.merge(newBlockMap)\n  });\n};\n\nconst serializeStyle = char => {\n  const charStyles = char.get(\"style\");\n  const initStyles = OrderedSet();\n\n  const styleReducer = (style = initStyles, value) => {\n    if (Array.isArray(value)) {\n      for (const str of value) {\n        style = styleReducer(style, str);\n      }\n    } else if (value) {\n      style = style.add(value);\n    }\n\n    return style;\n  };\n\n  const reducedStyles = charStyles.reduce(styleReducer, initStyles);\n  return char.set(\"style\", reducedStyles);\n}; // This functionality has been taken from draft-js and modified for re-usability purposes.\n// Maps over the selected characters, and applies a function to each character.\n// Characters are of type CharacterMetadata.\n\n\nconst mapSelectedCharacters = callback => (contentState, selectionState) => {\n  const blockMap = contentState.getBlockMap();\n  const startKey = selectionState.getStartKey();\n  const startOffset = selectionState.getStartOffset();\n  const endKey = selectionState.getEndKey();\n  const endOffset = selectionState.getEndOffset();\n  const newBlocks = blockMap.skipUntil((_, k) => {\n    return k === startKey;\n  }).takeUntil((_, k) => {\n    return k === endKey;\n  }).concat(Map([[endKey, blockMap.get(endKey)]])).map((block, blockKey) => {\n    let sliceStart;\n    let sliceEnd; // sliceStart -> where the selection starts\n    // endSlice -> Where the selection ends\n    // Only 1 block selected\n\n    if (startKey === endKey) {\n      sliceStart = startOffset;\n      sliceEnd = endOffset; // Gets the selected characters of the block when multiple blocks are selected.\n    } else {\n      sliceStart = blockKey === startKey ? startOffset : 0;\n      sliceEnd = blockKey === endKey ? endOffset : block.getLength();\n    } // Get the characters of the current block\n\n\n    let chars = block.getCharacterList();\n    let current;\n\n    while (sliceStart < sliceEnd) {\n      current = chars.get(sliceStart);\n      const newChar = callback(current);\n      chars = chars.set(sliceStart, newChar);\n      sliceStart++;\n    }\n\n    return block.set(\"characterList\", chars);\n  });\n  return contentState.merge({\n    blockMap: blockMap.merge(newBlocks),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\n\nconst getContentStateWithoutStyle = (prefix, contentState, selectionState) => {\n  return mapSelectedCharacters(filterDynamicStyle(prefix))(contentState, selectionState);\n};\n\nconst filterDynamicStyle = prefix => char => {\n  const charStyles = char.get(\"style\");\n  const filteredStyles = charStyles.filter(style => !style.startsWith(prefix));\n  return char.set(\"style\", filteredStyles);\n};\n\nexport const applyInlineStyle = (editorState, inline, value) => {\n  const newState = removeInlineStyle(editorState, inline);\n  const contentState = newState.getCurrentContent();\n  const selectionState = newState.getSelection();\n  return EditorState.push(editorState, Modifier.applyInlineStyle(contentState, selectionState, inline + value), \"change-inline-style\");\n};\nexport const removeInlineStyle = (editorState, inline) => {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  return EditorState.push(editorState, getContentStateWithoutStyle(inline, contentState, selectionState), \"change-inline-style\");\n}; //If user move text editor lost the focus, user not able to see the selected text.\n//So we added highlight layer for the selector temporarily.\n\nexport const toggleHighlight = (editorState, showSelection = false) => {\n  const selection = editorState.getSelection();\n  const hasFocus = selection.getHasFocus();\n  const hasHightLight = editorState.getCurrentInlineStyle().has(INLINE_STYLE_HIGHLIGHT);\n\n  if (showSelection && !hasFocus && !hasHightLight) {\n    return applyInlineStyle(editorState, INLINE_STYLE_HIGHLIGHT, \"\");\n  } else if (hasHightLight && (hasFocus || !showSelection)) {\n    return removeInlineStyle(editorState, INLINE_STYLE_HIGHLIGHT);\n  }\n\n  return editorState;\n};\nexport const toggleAlignment = (editorState, align) => {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  const isAligned = getSelectedBlocksMap(editorState).every(block => (block === null || block === void 0 ? void 0 : block.getData().get(\"textAlign\")) === align);\n  const blockData = Map().set(\"textAlign\", isAligned ? undefined : align);\n  const newState = Modifier.mergeBlockData(contentState, selectionState, blockData);\n  return EditorState.push(editorState, newState, \"change-block-data\");\n};\nconst inlineStyles = [INLINE_STYLE_BOLD, INLINE_STYLE_ITALIC, INLINE_STYLE_UNDERLINE];\nconst inlineStyles2 = [INLINE_STYLE_FONT_PREFIX, INLINE_STYLE_SIZE_PREFIX, INLINE_STYLE_COLOR_PREFIX, INLINE_STYLE_BG_COLOR_PREFIX];\n\nconst removeInlineStyles = editorState => {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  const newContentState = inlineStyles.reduce((newState, style) => Modifier.removeInlineStyle(newState, selectionState, style), contentState);\n  const newContentState2 = inlineStyles2.reduce((newState, style) => getContentStateWithoutStyle(style, newState, selectionState), newContentState);\n  return EditorState.push(editorState, newContentState2, \"change-inline-style\");\n};\n\nconst removeEntities = editorState => {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  const newContentState = Modifier.applyEntity(contentState, selectionState, null);\n  return EditorState.push(editorState, newContentState, \"apply-entity\");\n};\n\nconst getSelectedBlocksMap = editorState => {\n  const selectionState = editorState.getSelection();\n  const contentState = editorState.getCurrentContent();\n  const startKey = selectionState.getStartKey();\n  const endKey = selectionState.getEndKey();\n  const blockMap = contentState.getBlockMap();\n  return blockMap.toSeq().skipUntil((_, k) => k === startKey).takeUntil((_, k) => k === endKey).concat([[endKey, blockMap.get(endKey)]]);\n};\n\nconst removeBlockTypes = editorState => {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  const blockData = Map();\n  let newState = contentState;\n  newState = Modifier.setBlockType(newState, selectionState, \"unstyled\");\n  newState = Modifier.setBlockData(newState, selectionState, blockData);\n  return EditorState.push(editorState, newState, \"change-block-type\");\n};\n\nexport const cleareStyles = editorState => {\n  return removeBlockTypes(removeEntities(removeInlineStyles(editorState)));\n};","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/src/components/component-editor/text/utils.tsx"],"names":["EditorState","Modifier","stateFromHTML","stateToHTML","Map","OrderedSet","decorator","stateConfig","htmlConfig","INLINE_STYLE_BG_COLOR_PREFIX","INLINE_STYLE_BOLD","INLINE_STYLE_COLOR_PREFIX","INLINE_STYLE_FONT_PREFIX","INLINE_STYLE_SIZE_PREFIX","INLINE_STYLE_HIGHLIGHT","INLINE_STYLE_ITALIC","INLINE_STYLE_UNDERLINE","createEditorState","html","content","newContent","serializeContent","createWithContent","createEditorHTML","state","newState","removeInlineStyle","getCurrentContent","hasText","decodeHTML","str","replace","contentState","blockMap","getBlockMap","newBlockMap","map","block","list","getCharacterList","char","serializeStyle","set","merge","charStyles","get","initStyles","styleReducer","style","value","Array","isArray","add","reducedStyles","reduce","mapSelectedCharacters","callback","selectionState","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","newBlocks","skipUntil","_","k","takeUntil","concat","blockKey","sliceStart","sliceEnd","getLength","chars","current","newChar","selectionBefore","selectionAfter","getContentStateWithoutStyle","prefix","filterDynamicStyle","filteredStyles","filter","startsWith","applyInlineStyle","editorState","inline","getSelection","push","toggleHighlight","showSelection","selection","hasFocus","getHasFocus","hasHightLight","getCurrentInlineStyle","has","toggleAlignment","align","isAligned","getSelectedBlocksMap","every","getData","blockData","undefined","mergeBlockData","inlineStyles","inlineStyles2","removeInlineStyles","newContentState","newContentState2","removeEntities","applyEntity","toSeq","removeBlockTypes","setBlockType","setBlockData","cleareStyles"],"mappings":"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","sourcesContent":["import { CharacterMetadata, ContentState, EditorState, Modifier, SelectionState } from \"draft-js\";\r\nimport { stateFromHTML } from \"draft-js-import-html\";\r\nimport { stateToHTML } from \"draft-js-export-html\";\r\nimport { Map, OrderedSet } from \"immutable\";\r\n\r\nimport { decorator, stateConfig, htmlConfig } from \"./config\";\r\nimport {\r\n  INLINE_STYLE_BG_COLOR_PREFIX,\r\n  INLINE_STYLE_BOLD,\r\n  INLINE_STYLE_COLOR_PREFIX,\r\n  INLINE_STYLE_FONT_PREFIX,\r\n  INLINE_STYLE_SIZE_PREFIX,\r\n  INLINE_STYLE_HIGHLIGHT,\r\n  INLINE_STYLE_ITALIC,\r\n  INLINE_STYLE_UNDERLINE,\r\n} from \"editor-constants\";\r\n\r\ntype DraftInlineStyle = Immutable.OrderedSet<string>;\r\ntype DraftInlineMap = Map<string, DraftInlineStyle>;\r\n\r\nexport const createEditorState = (html: string) => {\r\n  const content = stateFromHTML(html, stateConfig as any);\r\n  const newContent = serializeContent(content);\r\n\r\n  return EditorState.createWithContent(newContent, decorator);\r\n};\r\n\r\nexport const createEditorHTML = (state: EditorState) => {\r\n  const newState = removeInlineStyle(state, INLINE_STYLE_HIGHLIGHT);\r\n  const content = newState.getCurrentContent();\r\n  const html = content.hasText() ? stateToHTML(content, htmlConfig) : \"\";\r\n\r\n  return decodeHTML(html);\r\n};\r\n\r\nconst decodeHTML = (str: string) => {\r\n  return str.replace(/&nbsp;/g, \"\\xA0\");\r\n};\r\n\r\n//https://github.com/sstur/draft-js-utils/pull/155/checks\r\n//This function serialize multiple nested inline array into single inline style array\r\n//After above PR is approved and include in release we can remove this function.\r\n//This function avoid that we need to check inline style are single or nested array in other utill functions\r\nconst serializeContent = (contentState: ContentState) => {\r\n  const blockMap = contentState.getBlockMap();\r\n\r\n  const newBlockMap = blockMap.map((block) => {\r\n    let list = block!.getCharacterList();\r\n\r\n    list = list.map((char) => {\r\n      return serializeStyle(char as any);\r\n    }) as any;\r\n\r\n    return block!.set(\"characterList\", list);\r\n  });\r\n\r\n  return contentState.merge({\r\n    blockMap: blockMap.merge(newBlockMap as any),\r\n  }) as ContentState;\r\n};\r\n\r\nconst serializeStyle = (char: DraftInlineMap) => {\r\n  const charStyles = char.get(\"style\");\r\n  const initStyles = OrderedSet<string>();\r\n  const styleReducer = (style = initStyles, value?: string) => {\r\n    if (Array.isArray(value)) {\r\n      for (const str of value) {\r\n        style = styleReducer(style, str);\r\n      }\r\n    } else if (value) {\r\n      style = style.add(value);\r\n    }\r\n    return style;\r\n  };\r\n  const reducedStyles = charStyles.reduce(styleReducer, initStyles);\r\n\r\n  return char.set(\"style\", reducedStyles);\r\n};\r\n\r\n// This functionality has been taken from draft-js and modified for re-usability purposes.\r\n// Maps over the selected characters, and applies a function to each character.\r\n// Characters are of type CharacterMetadata.\r\nconst mapSelectedCharacters =\r\n  (callback: (arg: DraftInlineMap) => DraftInlineMap) =>\r\n  (contentState: ContentState, selectionState: SelectionState) => {\r\n    const blockMap = contentState.getBlockMap();\r\n    const startKey = selectionState.getStartKey();\r\n    const startOffset = selectionState.getStartOffset();\r\n    const endKey = selectionState.getEndKey();\r\n    const endOffset = selectionState.getEndOffset();\r\n\r\n    const newBlocks = blockMap\r\n      .skipUntil((_, k) => {\r\n        return k === startKey;\r\n      })\r\n      .takeUntil((_, k) => {\r\n        return k === endKey;\r\n      })\r\n      .concat(Map([[endKey, blockMap.get(endKey)]]))\r\n      .map((block, blockKey) => {\r\n        let sliceStart;\r\n        let sliceEnd;\r\n        // sliceStart -> where the selection starts\r\n        // endSlice -> Where the selection ends\r\n\r\n        // Only 1 block selected\r\n        if (startKey === endKey) {\r\n          sliceStart = startOffset;\r\n          sliceEnd = endOffset;\r\n          // Gets the selected characters of the block when multiple blocks are selected.\r\n        } else {\r\n          sliceStart = blockKey === startKey ? startOffset : 0;\r\n          sliceEnd = blockKey === endKey ? endOffset : block!.getLength();\r\n        }\r\n\r\n        // Get the characters of the current block\r\n        let chars = block!.getCharacterList();\r\n        let current: CharacterMetadata;\r\n\r\n        while (sliceStart < sliceEnd) {\r\n          current = chars.get(sliceStart);\r\n          const newChar = callback(current as any);\r\n          chars = chars.set(sliceStart, newChar as any);\r\n          sliceStart++;\r\n        }\r\n\r\n        return block!.set(\"characterList\", chars);\r\n      });\r\n\r\n    return contentState.merge({\r\n      blockMap: blockMap.merge(newBlocks as any),\r\n      selectionBefore: selectionState,\r\n      selectionAfter: selectionState,\r\n    }) as ContentState;\r\n  };\r\n\r\nconst getContentStateWithoutStyle = (\r\n  prefix: string,\r\n  contentState: ContentState,\r\n  selectionState: SelectionState\r\n) => {\r\n  return mapSelectedCharacters(filterDynamicStyle(prefix))(contentState, selectionState);\r\n};\r\n\r\nconst filterDynamicStyle = (prefix: string) => (char: DraftInlineMap) => {\r\n  const charStyles = char.get(\"style\");\r\n  const filteredStyles = charStyles.filter((style) => !style!.startsWith(prefix));\r\n\r\n  return char.set(\"style\", filteredStyles as DraftInlineStyle);\r\n};\r\n\r\nexport const applyInlineStyle = (editorState: EditorState, inline: string, value: string) => {\r\n  const newState = removeInlineStyle(editorState, inline);\r\n  const contentState = newState.getCurrentContent();\r\n  const selectionState = newState.getSelection();\r\n\r\n  return EditorState.push(\r\n    editorState,\r\n    Modifier.applyInlineStyle(contentState, selectionState, inline + value),\r\n    \"change-inline-style\"\r\n  );\r\n};\r\n\r\nexport const removeInlineStyle = (editorState: EditorState, inline: string) => {\r\n  const contentState = editorState.getCurrentContent();\r\n  const selectionState = editorState.getSelection();\r\n\r\n  return EditorState.push(\r\n    editorState,\r\n    getContentStateWithoutStyle(inline, contentState, selectionState),\r\n    \"change-inline-style\"\r\n  );\r\n};\r\n\r\n//If user move text editor lost the focus, user not able to see the selected text.\r\n//So we added highlight layer for the selector temporarily.\r\nexport const toggleHighlight = (editorState: EditorState, showSelection = false) => {\r\n  const selection = editorState.getSelection();\r\n  const hasFocus = selection.getHasFocus();\r\n  const hasHightLight = editorState.getCurrentInlineStyle().has(INLINE_STYLE_HIGHLIGHT);\r\n\r\n  if (showSelection && !hasFocus && !hasHightLight) {\r\n    return applyInlineStyle(editorState, INLINE_STYLE_HIGHLIGHT, \"\");\r\n  } else if (hasHightLight && (hasFocus || !showSelection)) {\r\n    return removeInlineStyle(editorState, INLINE_STYLE_HIGHLIGHT);\r\n  }\r\n\r\n  return editorState;\r\n};\r\n\r\nexport const toggleAlignment = (editorState: EditorState, align: string) => {\r\n  const contentState = editorState.getCurrentContent();\r\n  const selectionState = editorState.getSelection();\r\n  const isAligned = getSelectedBlocksMap(editorState).every(\r\n    (block) => block?.getData().get(\"textAlign\") === align\r\n  );\r\n  const blockData = Map().set(\"textAlign\", isAligned ? undefined : align);\r\n  const newState = Modifier.mergeBlockData(contentState, selectionState, blockData);\r\n\r\n  return EditorState.push(editorState, newState, \"change-block-data\");\r\n};\r\n\r\nconst inlineStyles = [INLINE_STYLE_BOLD, INLINE_STYLE_ITALIC, INLINE_STYLE_UNDERLINE];\r\nconst inlineStyles2 = [\r\n  INLINE_STYLE_FONT_PREFIX,\r\n  INLINE_STYLE_SIZE_PREFIX,\r\n  INLINE_STYLE_COLOR_PREFIX,\r\n  INLINE_STYLE_BG_COLOR_PREFIX,\r\n];\r\n\r\nconst removeInlineStyles = (editorState: EditorState) => {\r\n  const contentState = editorState.getCurrentContent();\r\n  const selectionState = editorState.getSelection();\r\n  const newContentState = inlineStyles.reduce(\r\n    (newState, style) => Modifier.removeInlineStyle(newState, selectionState, style),\r\n    contentState\r\n  );\r\n  const newContentState2 = inlineStyles2.reduce(\r\n    (newState, style) => getContentStateWithoutStyle(style, newState, selectionState),\r\n    newContentState\r\n  );\r\n\r\n  return EditorState.push(editorState, newContentState2, \"change-inline-style\");\r\n};\r\n\r\nconst removeEntities = (editorState: EditorState) => {\r\n  const contentState = editorState.getCurrentContent();\r\n  const selectionState = editorState.getSelection();\r\n  const newContentState = Modifier.applyEntity(contentState, selectionState, null);\r\n\r\n  return EditorState.push(editorState, newContentState, \"apply-entity\");\r\n};\r\n\r\nconst getSelectedBlocksMap = (editorState: EditorState) => {\r\n  const selectionState = editorState.getSelection();\r\n  const contentState = editorState.getCurrentContent();\r\n  const startKey = selectionState.getStartKey();\r\n  const endKey = selectionState.getEndKey();\r\n  const blockMap = contentState.getBlockMap();\r\n\r\n  return blockMap\r\n    .toSeq()\r\n    .skipUntil((_, k) => k === startKey)\r\n    .takeUntil((_, k) => k === endKey)\r\n    .concat([[endKey, blockMap.get(endKey)]]);\r\n};\r\n\r\nconst removeBlockTypes = (editorState: EditorState) => {\r\n  const contentState = editorState.getCurrentContent();\r\n  const selectionState = editorState.getSelection();\r\n  const blockData = Map();\r\n  let newState = contentState;\r\n\r\n  newState = Modifier.setBlockType(newState, selectionState, \"unstyled\");\r\n  newState = Modifier.setBlockData(newState, selectionState, blockData);\r\n\r\n  return EditorState.push(editorState, newState, \"change-block-type\");\r\n};\r\n\r\nexport const cleareStyles = (editorState: EditorState) => {\r\n  return removeBlockTypes(removeEntities(removeInlineStyles(editorState)));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}