{"ast":null,"code":"import { parseTimestamp, validTimestamp } from \"utils\";\n/**\r\n * See spec: https://www.w3.org/TR/webvtt1/#file-structure\r\n * https://github.com/osk/node-webvtt/blob/master/lib/parser.js\r\n */\n\nexport function parseWebVTT(input, options) {\n  const {\n    meta = false,\n    strict = true\n  } = options || {};\n  input = input.trim();\n  input = input.replace(/\\r\\n/g, \"\\n\");\n  input = input.replace(/\\r/g, \"\\n\");\n  const parts = input.split(\"\\n\\n\");\n  const header = parts.shift();\n\n  if (!(header === null || header === void 0 ? void 0 : header.startsWith(\"WEBVTT\"))) {\n    throw new Error('Must start with \"WEBVTT\"');\n  }\n\n  const headerParts = header.split(\"\\n\");\n  const headerComments = headerParts[0].replace(\"WEBVTT\", \"\");\n\n  if (headerComments.length > 0 && headerComments[0] !== \" \" && headerComments[0] !== \"\\t\") {\n    throw new Error(\"Header comment must start with space or tab\");\n  } // nothing of interests, return early\n\n\n  if (parts.length === 0 && headerParts.length === 1) {\n    return {\n      valid: true,\n      strict,\n      cues: [],\n      errors: []\n    };\n  }\n\n  if (!meta && headerParts.length > 1 && headerParts[1] !== \"\") {\n    throw new Error(\"Missing blank line after signature\");\n  }\n\n  const {\n    cues,\n    errors\n  } = parseCues(parts, strict);\n\n  if (strict && errors.length > 0) {\n    throw new Error(errors[0]);\n  }\n\n  const headerMeta = meta ? parseMeta(headerParts) : null;\n  const result = {\n    valid: errors.length === 0,\n    strict,\n    cues,\n    errors\n  };\n\n  if (meta) {\n    result.meta = headerMeta;\n  }\n\n  return result;\n}\n\nfunction parseMeta(headerParts) {\n  const meta = {};\n  headerParts.slice(1).forEach(header => {\n    const splitIdx = header.indexOf(\":\");\n    const key = header.slice(0, splitIdx).trim();\n    const value = header.slice(splitIdx + 1).trim();\n    meta[key] = value;\n  });\n  return Object.keys(meta).length > 0 ? meta : null;\n}\n\nfunction parseCues(cues, strict) {\n  const errors = [];\n  const parsedCues = cues.map((cue, i) => {\n    try {\n      return parseCue(cue, i, strict);\n    } catch (e) {\n      errors.push(e);\n      return null;\n    }\n  }).filter(Boolean);\n  return {\n    cues: parsedCues,\n    errors\n  };\n}\n/**\r\n * Parse a single cue block.\r\n *\r\n * @param {array} cue Array of content for the cue\r\n * @param {number} i Index of cue in array\r\n *\r\n * @returns {object} cue Cue object with start, end, text and styles.\r\n *                       Null if it's a note\r\n */\n\n\nfunction parseCue(cue, i, strict) {\n  let identifier = \"\";\n  let start = 0;\n  let end = 0.01;\n  let text = \"\";\n  let styles = \"\"; // split and remove empty lines\n\n  const lines = cue.split(\"\\n\").filter(Boolean);\n\n  if (lines.length > 0 && lines[0].trim().startsWith(\"NOTE\")) {\n    return null;\n  }\n\n  if (lines.length === 1 && !lines[0].includes(\"-->\")) {\n    throw new Error(`Cue identifier cannot be standalone (cue #${i})`);\n  }\n\n  if (lines.length > 1 && !(lines[0].includes(\"-->\") || lines[1].includes(\"-->\"))) {\n    throw new Error(`Cue identifier needs to be followed by timestamp (cue #${i})`);\n  }\n\n  if (lines.length > 1 && lines[1].includes(\"-->\")) {\n    identifier = lines.shift() || \"\";\n  }\n\n  const times = typeof lines[0] === \"string\" ? lines[0].split(\" --> \") : [];\n\n  if (times.length !== 2 || !validTimestamp(times[0]) || !validTimestamp(times[1])) {\n    throw new Error(`Invalid cue timestamp (cue #${i})`);\n  }\n\n  start = parseTimestamp(times[0]);\n  end = parseTimestamp(times[1]);\n\n  if (strict) {\n    if (start > end) {\n      throw new Error(`Start timestamp greater than end (cue #${i})`);\n    }\n\n    if (end <= start) {\n      throw new Error(`End must be greater than start (cue #${i})`);\n    }\n  }\n\n  if (!strict && end < start) {\n    throw new Error(`End must be greater or equal to start when not strict (cue #${i})`);\n  }\n\n  lines.shift();\n  text = lines.join(\"\\n\") || \"\";\n  return {\n    identifier,\n    start,\n    end,\n    text,\n    styles\n  };\n}","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/src/utils/core/webvtt-parser.ts"],"names":["parseTimestamp","validTimestamp","parseWebVTT","input","options","meta","strict","trim","replace","parts","split","header","shift","startsWith","Error","headerParts","headerComments","length","valid","cues","errors","parseCues","headerMeta","parseMeta","result","slice","forEach","splitIdx","indexOf","key","value","Object","keys","parsedCues","map","cue","i","parseCue","e","push","filter","Boolean","identifier","start","end","text","styles","lines","includes","times","join"],"mappings":"AACA,SAASA,cAAT,EAAyBC,cAAzB,QAA+C,OAA/C;AAEA;;;;;AAIA,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAAoCC,OAApC,EAAoF;AACzF,QAAM;AAAEC,IAAAA,IAAI,GAAG,KAAT;AAAgBC,IAAAA,MAAM,GAAG;AAAzB,MAAkCF,OAAO,IAAI,EAAnD;AAEAD,EAAAA,KAAK,GAAGA,KAAK,CAACI,IAAN,EAAR;AACAJ,EAAAA,KAAK,GAAGA,KAAK,CAACK,OAAN,CAAc,OAAd,EAAuB,IAAvB,CAAR;AACAL,EAAAA,KAAK,GAAGA,KAAK,CAACK,OAAN,CAAc,KAAd,EAAqB,IAArB,CAAR;AAEA,QAAMC,KAAK,GAAGN,KAAK,CAACO,KAAN,CAAY,MAAZ,CAAd;AACA,QAAMC,MAAM,GAAGF,KAAK,CAACG,KAAN,EAAf;;AAEA,MAAI,EAACD,MAAD,aAACA,MAAD,uBAACA,MAAM,CAAEE,UAAR,CAAmB,QAAnB,CAAD,CAAJ,EAAmC;AACjC,UAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACD;;AAED,QAAMC,WAAW,GAAGJ,MAAM,CAACD,KAAP,CAAa,IAAb,CAApB;AACA,QAAMM,cAAc,GAAGD,WAAW,CAAC,CAAD,CAAX,CAAeP,OAAf,CAAuB,QAAvB,EAAiC,EAAjC,CAAvB;;AAEA,MAAIQ,cAAc,CAACC,MAAf,GAAwB,CAAxB,IAA6BD,cAAc,CAAC,CAAD,CAAd,KAAsB,GAAnD,IAA0DA,cAAc,CAAC,CAAD,CAAd,KAAsB,IAApF,EAA0F;AACxF,UAAM,IAAIF,KAAJ,CAAU,6CAAV,CAAN;AACD,GAnBwF,CAqBzF;;;AACA,MAAIL,KAAK,CAACQ,MAAN,KAAiB,CAAjB,IAAsBF,WAAW,CAACE,MAAZ,KAAuB,CAAjD,EAAoD;AAClD,WAAO;AAAEC,MAAAA,KAAK,EAAE,IAAT;AAAeZ,MAAAA,MAAf;AAAuBa,MAAAA,IAAI,EAAE,EAA7B;AAAiCC,MAAAA,MAAM,EAAE;AAAzC,KAAP;AACD;;AAED,MAAI,CAACf,IAAD,IAASU,WAAW,CAACE,MAAZ,GAAqB,CAA9B,IAAmCF,WAAW,CAAC,CAAD,CAAX,KAAmB,EAA1D,EAA8D;AAC5D,UAAM,IAAID,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAM;AAAEK,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAmBC,SAAS,CAACZ,KAAD,EAAQH,MAAR,CAAlC;;AAEA,MAAIA,MAAM,IAAIc,MAAM,CAACH,MAAP,GAAgB,CAA9B,EAAiC;AAC/B,UAAM,IAAIH,KAAJ,CAAUM,MAAM,CAAC,CAAD,CAAhB,CAAN;AACD;;AAED,QAAME,UAAU,GAAGjB,IAAI,GAAGkB,SAAS,CAACR,WAAD,CAAZ,GAA4B,IAAnD;AACA,QAAMS,MAML,GAAG;AACFN,IAAAA,KAAK,EAAEE,MAAM,CAACH,MAAP,KAAkB,CADvB;AAEFX,IAAAA,MAFE;AAGFa,IAAAA,IAHE;AAIFC,IAAAA;AAJE,GANJ;;AAaA,MAAIf,IAAJ,EAAU;AACRmB,IAAAA,MAAM,CAACnB,IAAP,GAAciB,UAAd;AACD;;AAED,SAAOE,MAAP;AACD;;AAED,SAASD,SAAT,CAAmBR,WAAnB,EAA0C;AACxC,QAAMV,IAAkB,GAAG,EAA3B;AAEAU,EAAAA,WAAW,CAACU,KAAZ,CAAkB,CAAlB,EAAqBC,OAArB,CAA8Bf,MAAD,IAAY;AACvC,UAAMgB,QAAQ,GAAGhB,MAAM,CAACiB,OAAP,CAAe,GAAf,CAAjB;AACA,UAAMC,GAAG,GAAGlB,MAAM,CAACc,KAAP,CAAa,CAAb,EAAgBE,QAAhB,EAA0BpB,IAA1B,EAAZ;AACA,UAAMuB,KAAK,GAAGnB,MAAM,CAACc,KAAP,CAAaE,QAAQ,GAAG,CAAxB,EAA2BpB,IAA3B,EAAd;AAEAF,IAAAA,IAAI,CAACwB,GAAD,CAAJ,GAAYC,KAAZ;AACD,GAND;AAQA,SAAOC,MAAM,CAACC,IAAP,CAAY3B,IAAZ,EAAkBY,MAAlB,GAA2B,CAA3B,GAA+BZ,IAA/B,GAAsC,IAA7C;AACD;;AAED,SAASgB,SAAT,CAAmBF,IAAnB,EAAmCb,MAAnC,EAAoD;AAClD,QAAMc,MAAgB,GAAG,EAAzB;AACA,QAAMa,UAAU,GAAGd,IAAI,CACpBe,GADgB,CACZ,CAACC,GAAD,EAAMC,CAAN,KAAY;AACf,QAAI;AACF,aAAOC,QAAQ,CAACF,GAAD,EAAMC,CAAN,EAAS9B,MAAT,CAAf;AACD,KAFD,CAEE,OAAOgC,CAAP,EAAU;AACVlB,MAAAA,MAAM,CAACmB,IAAP,CAAYD,CAAZ;AACA,aAAO,IAAP;AACD;AACF,GARgB,EAShBE,MATgB,CASTC,OATS,CAAnB;AAWA,SAAO;AACLtB,IAAAA,IAAI,EAAEc,UADD;AAELb,IAAAA;AAFK,GAAP;AAID;AAED;;;;;;;;;;;AASA,SAASiB,QAAT,CAAkBF,GAAlB,EAA+BC,CAA/B,EAA0C9B,MAA1C,EAA2D;AACzD,MAAIoC,UAAU,GAAG,EAAjB;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAG,IAAV;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,MAAM,GAAG,EAAb,CALyD,CAOzD;;AACA,QAAMC,KAAK,GAAGZ,GAAG,CAACzB,KAAJ,CAAU,IAAV,EAAgB8B,MAAhB,CAAuBC,OAAvB,CAAd;;AAEA,MAAIM,KAAK,CAAC9B,MAAN,GAAe,CAAf,IAAoB8B,KAAK,CAAC,CAAD,CAAL,CAASxC,IAAT,GAAgBM,UAAhB,CAA2B,MAA3B,CAAxB,EAA4D;AAC1D,WAAO,IAAP;AACD;;AAED,MAAIkC,KAAK,CAAC9B,MAAN,KAAiB,CAAjB,IAAsB,CAAC8B,KAAK,CAAC,CAAD,CAAL,CAASC,QAAT,CAAkB,KAAlB,CAA3B,EAAqD;AACnD,UAAM,IAAIlC,KAAJ,CAAW,6CAA4CsB,CAAE,GAAzD,CAAN;AACD;;AAED,MAAIW,KAAK,CAAC9B,MAAN,GAAe,CAAf,IAAoB,EAAE8B,KAAK,CAAC,CAAD,CAAL,CAASC,QAAT,CAAkB,KAAlB,KAA4BD,KAAK,CAAC,CAAD,CAAL,CAASC,QAAT,CAAkB,KAAlB,CAA9B,CAAxB,EAAiF;AAC/E,UAAM,IAAIlC,KAAJ,CAAW,0DAAyDsB,CAAE,GAAtE,CAAN;AACD;;AAED,MAAIW,KAAK,CAAC9B,MAAN,GAAe,CAAf,IAAoB8B,KAAK,CAAC,CAAD,CAAL,CAASC,QAAT,CAAkB,KAAlB,CAAxB,EAAkD;AAChDN,IAAAA,UAAU,GAAGK,KAAK,CAACnC,KAAN,MAAiB,EAA9B;AACD;;AAED,QAAMqC,KAAK,GAAG,OAAOF,KAAK,CAAC,CAAD,CAAZ,KAAoB,QAApB,GAA+BA,KAAK,CAAC,CAAD,CAAL,CAASrC,KAAT,CAAe,OAAf,CAA/B,GAAyD,EAAvE;;AAEA,MAAIuC,KAAK,CAAChC,MAAN,KAAiB,CAAjB,IAAsB,CAAChB,cAAc,CAACgD,KAAK,CAAC,CAAD,CAAN,CAArC,IAAmD,CAAChD,cAAc,CAACgD,KAAK,CAAC,CAAD,CAAN,CAAtE,EAAkF;AAChF,UAAM,IAAInC,KAAJ,CAAW,+BAA8BsB,CAAE,GAA3C,CAAN;AACD;;AAEDO,EAAAA,KAAK,GAAG3C,cAAc,CAACiD,KAAK,CAAC,CAAD,CAAN,CAAtB;AACAL,EAAAA,GAAG,GAAG5C,cAAc,CAACiD,KAAK,CAAC,CAAD,CAAN,CAApB;;AAEA,MAAI3C,MAAJ,EAAY;AACV,QAAIqC,KAAK,GAAGC,GAAZ,EAAiB;AACf,YAAM,IAAI9B,KAAJ,CAAW,0CAAyCsB,CAAE,GAAtD,CAAN;AACD;;AAED,QAAIQ,GAAG,IAAID,KAAX,EAAkB;AAChB,YAAM,IAAI7B,KAAJ,CAAW,wCAAuCsB,CAAE,GAApD,CAAN;AACD;AACF;;AAED,MAAI,CAAC9B,MAAD,IAAWsC,GAAG,GAAGD,KAArB,EAA4B;AAC1B,UAAM,IAAI7B,KAAJ,CAAW,+DAA8DsB,CAAE,GAA3E,CAAN;AACD;;AAEDW,EAAAA,KAAK,CAACnC,KAAN;AAEAiC,EAAAA,IAAI,GAAGE,KAAK,CAACG,IAAN,CAAW,IAAX,KAAoB,EAA3B;AAEA,SAAO;AAAER,IAAAA,UAAF;AAAcC,IAAAA,KAAd;AAAqBC,IAAAA,GAArB;AAA0BC,IAAAA,IAA1B;AAAgCC,IAAAA;AAAhC,GAAP;AACD","sourcesContent":["import { SimpleObject } from \"types\";\r\nimport { parseTimestamp, validTimestamp } from \"utils\";\r\n\r\n/**\r\n * See spec: https://www.w3.org/TR/webvtt1/#file-structure\r\n * https://github.com/osk/node-webvtt/blob/master/lib/parser.js\r\n */\r\nexport function parseWebVTT(input: string, options?: { meta?: boolean; strict?: boolean }) {\r\n  const { meta = false, strict = true } = options || {};\r\n\r\n  input = input.trim();\r\n  input = input.replace(/\\r\\n/g, \"\\n\");\r\n  input = input.replace(/\\r/g, \"\\n\");\r\n\r\n  const parts = input.split(\"\\n\\n\");\r\n  const header = parts.shift();\r\n\r\n  if (!header?.startsWith(\"WEBVTT\")) {\r\n    throw new Error('Must start with \"WEBVTT\"');\r\n  }\r\n\r\n  const headerParts = header.split(\"\\n\");\r\n  const headerComments = headerParts[0].replace(\"WEBVTT\", \"\");\r\n\r\n  if (headerComments.length > 0 && headerComments[0] !== \" \" && headerComments[0] !== \"\\t\") {\r\n    throw new Error(\"Header comment must start with space or tab\");\r\n  }\r\n\r\n  // nothing of interests, return early\r\n  if (parts.length === 0 && headerParts.length === 1) {\r\n    return { valid: true, strict, cues: [], errors: [] };\r\n  }\r\n\r\n  if (!meta && headerParts.length > 1 && headerParts[1] !== \"\") {\r\n    throw new Error(\"Missing blank line after signature\");\r\n  }\r\n\r\n  const { cues, errors } = parseCues(parts, strict);\r\n\r\n  if (strict && errors.length > 0) {\r\n    throw new Error(errors[0]);\r\n  }\r\n\r\n  const headerMeta = meta ? parseMeta(headerParts) : null;\r\n  const result: {\r\n    valid: boolean;\r\n    strict: boolean;\r\n    meta?: typeof headerMeta;\r\n    cues: typeof cues;\r\n    errors: typeof errors;\r\n  } = {\r\n    valid: errors.length === 0,\r\n    strict,\r\n    cues,\r\n    errors,\r\n  };\r\n\r\n  if (meta) {\r\n    result.meta = headerMeta;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction parseMeta(headerParts: string[]) {\r\n  const meta: SimpleObject = {};\r\n\r\n  headerParts.slice(1).forEach((header) => {\r\n    const splitIdx = header.indexOf(\":\");\r\n    const key = header.slice(0, splitIdx).trim();\r\n    const value = header.slice(splitIdx + 1).trim();\r\n\r\n    meta[key] = value;\r\n  });\r\n\r\n  return Object.keys(meta).length > 0 ? meta : null;\r\n}\r\n\r\nfunction parseCues(cues: string[], strict: boolean) {\r\n  const errors: string[] = [];\r\n  const parsedCues = cues\r\n    .map((cue, i) => {\r\n      try {\r\n        return parseCue(cue, i, strict);\r\n      } catch (e) {\r\n        errors.push(e as string);\r\n        return null;\r\n      }\r\n    })\r\n    .filter(Boolean) as Exclude<ReturnType<typeof parseCue>, null>[];\r\n\r\n  return {\r\n    cues: parsedCues,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Parse a single cue block.\r\n *\r\n * @param {array} cue Array of content for the cue\r\n * @param {number} i Index of cue in array\r\n *\r\n * @returns {object} cue Cue object with start, end, text and styles.\r\n *                       Null if it's a note\r\n */\r\nfunction parseCue(cue: string, i: number, strict: boolean) {\r\n  let identifier = \"\";\r\n  let start = 0;\r\n  let end = 0.01;\r\n  let text = \"\";\r\n  let styles = \"\";\r\n\r\n  // split and remove empty lines\r\n  const lines = cue.split(\"\\n\").filter(Boolean);\r\n\r\n  if (lines.length > 0 && lines[0].trim().startsWith(\"NOTE\")) {\r\n    return null;\r\n  }\r\n\r\n  if (lines.length === 1 && !lines[0].includes(\"-->\")) {\r\n    throw new Error(`Cue identifier cannot be standalone (cue #${i})`);\r\n  }\r\n\r\n  if (lines.length > 1 && !(lines[0].includes(\"-->\") || lines[1].includes(\"-->\"))) {\r\n    throw new Error(`Cue identifier needs to be followed by timestamp (cue #${i})`);\r\n  }\r\n\r\n  if (lines.length > 1 && lines[1].includes(\"-->\")) {\r\n    identifier = lines.shift() || \"\";\r\n  }\r\n\r\n  const times = typeof lines[0] === \"string\" ? lines[0].split(\" --> \") : [];\r\n\r\n  if (times.length !== 2 || !validTimestamp(times[0]) || !validTimestamp(times[1])) {\r\n    throw new Error(`Invalid cue timestamp (cue #${i})`);\r\n  }\r\n\r\n  start = parseTimestamp(times[0]);\r\n  end = parseTimestamp(times[1]);\r\n\r\n  if (strict) {\r\n    if (start > end) {\r\n      throw new Error(`Start timestamp greater than end (cue #${i})`);\r\n    }\r\n\r\n    if (end <= start) {\r\n      throw new Error(`End must be greater than start (cue #${i})`);\r\n    }\r\n  }\r\n\r\n  if (!strict && end < start) {\r\n    throw new Error(`End must be greater or equal to start when not strict (cue #${i})`);\r\n  }\r\n\r\n  lines.shift();\r\n\r\n  text = lines.join(\"\\n\") || \"\";\r\n\r\n  return { identifier, start, end, text, styles };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}