{"ast":null,"code":"import { MediaCueActions, MediaTrackTypes } from \"editor-constants\";\nimport { PlayerState } from \"@lottiefiles/react-lottie-player\";\nexport function isMediaElement(media) {\n  return media instanceof HTMLMediaElement;\n}\nexport function isMediaPlaying(media) {\n  if (isMediaElement(media)) {\n    return !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  } else {\n    return media.state.playerState === PlayerState.Playing;\n  }\n}\nexport function cloneCue(target, source) {\n  return { ...target,\n    ...source\n  };\n}\nexport function cloneCues(cues, target, source) {\n  return cues.map(item => item === target ? cloneCue(target, source) : item);\n}\nexport function getCurrentVideoCues(cues, duration) {\n  return cues.filter(item => {\n    const {\n      startTime,\n      endTime\n    } = item;\n\n    if (isNaN(endTime)) {\n      return startTime >= 0 && startTime <= duration;\n    } else {\n      return startTime >= 0 && startTime <= duration && endTime >= 0 && endTime <= duration;\n    }\n  });\n}\nexport function getSubtitleMarkerCues(cues, duration) {\n  return cues.filter(item => {\n    const {\n      startTime,\n      endTime\n    } = item;\n\n    if (isNaN(endTime)) {\n      return startTime >= 0 && startTime <= duration;\n    } else {\n      return startTime >= 0 && startTime <= duration && endTime >= 0;\n    }\n  });\n}\nexport function getCurrentCues(type, cues, currentTime, duration) {\n  const totalTime = currentTime + duration;\n  return cues.filter(item => {\n    const {\n      startTime,\n      endTime\n    } = item;\n\n    if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\n      return startTime >= currentTime && startTime <= totalTime || endTime >= currentTime && endTime <= totalTime || startTime < currentTime && endTime > totalTime;\n    } else {\n      return startTime >= currentTime && startTime < totalTime;\n    }\n  });\n}\nexport function getCurrentCue(cues, currentTime) {\n  return cues.find((item, ind) => {\n    if (!item.action || item.action === MediaCueActions.ScrollVPauseC) {\n      return item.startTime <= currentTime && item.endTime > currentTime;\n    } else {\n      const next = cues[ind + 1];\n      return item.startTime <= currentTime && (!next || next.startTime > currentTime);\n    }\n  });\n}\nexport function validateCue(type, cues, cue) {\n  const {\n    startTime,\n    endTime\n  } = cue;\n  const index = cues.indexOf(cue);\n  const previous = cues[index - 1];\n\n  if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\n    return startTime >= 0 && endTime >= 0 && startTime < endTime && endTime - startTime > 0.2 && (!previous || previous.endTime < startTime);\n  } else {\n    return startTime >= 0 && (!previous || previous.startTime < startTime);\n  }\n}\nexport function findCueIndex(type, cues, currentTime) {\n  return cues.findIndex((cue, index) => {\n    const {\n      startTime,\n      endTime\n    } = cue;\n    const next = cues[index + 1];\n\n    if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\n      return startTime <= currentTime && endTime > currentTime || currentTime >= endTime && (!next || currentTime < next.startTime);\n    } else {\n      return startTime <= currentTime && (!next || currentTime < next.startTime);\n    }\n  });\n}\nexport function validateCues(type, cues) {\n  if (type === MediaTrackTypes.Contents) {\n    cues.forEach(cue => {\n      if (!cue.content) {\n        throw new Error(\"Please select simple content\");\n      }\n    });\n  }\n}\nexport function normalizeMarkers(markers, duration) {\n  return markers.map((marker, ind) => {\n    var _next$startTime;\n\n    const next = markers[ind + 1];\n    return { ...marker,\n      endTime: (_next$startTime = next === null || next === void 0 ? void 0 : next.startTime) !== null && _next$startTime !== void 0 ? _next$startTime : duration\n    };\n  });\n}\nexport function convertTimeToXPos(time, pxPerSec, scrollTime = 0) {\n  return (time - scrollTime) * pxPerSec;\n}\nexport function convertXPosToTime(xPos, pxPerSec, scrollTime = 0) {\n  return xPos / pxPerSec + scrollTime;\n}","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/src/components/shared/media-editor/utils/index.ts"],"names":["MediaCueActions","MediaTrackTypes","PlayerState","isMediaElement","media","HTMLMediaElement","isMediaPlaying","currentTime","paused","ended","readyState","state","playerState","Playing","cloneCue","target","source","cloneCues","cues","map","item","getCurrentVideoCues","duration","filter","startTime","endTime","isNaN","getSubtitleMarkerCues","getCurrentCues","type","totalTime","Subtitles","Labels","getCurrentCue","find","ind","action","ScrollVPauseC","next","validateCue","cue","index","indexOf","previous","findCueIndex","findIndex","validateCues","Contents","forEach","content","Error","normalizeMarkers","markers","marker","convertTimeToXPos","time","pxPerSec","scrollTime","convertXPosToTime","xPos"],"mappings":"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","sourcesContent":["import { MediaTrackCue } from \"types\";\r\nimport { MediaCueActions, MediaTrackTypes } from \"editor-constants\";\r\nimport { Player, PlayerState } from \"@lottiefiles/react-lottie-player\";\r\n\r\nexport function isMediaElement<T>(\r\n  media: HTMLMediaElement | T\r\n): media is HTMLVideoElement | HTMLAudioElement {\r\n  return media instanceof HTMLMediaElement;\r\n}\r\n\r\nexport function isMediaPlaying(media: HTMLMediaElement | Player) {\r\n  if (isMediaElement(media)) {\r\n    return !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\r\n  } else {\r\n    return media.state.playerState === PlayerState.Playing;\r\n  }\r\n}\r\n\r\nexport function cloneCue(target: MediaTrackCue, source: Partial<MediaTrackCue>) {\r\n  return { ...target, ...source };\r\n}\r\n\r\nexport function cloneCues(\r\n  cues: MediaTrackCue[],\r\n  target: MediaTrackCue,\r\n  source: Partial<MediaTrackCue>\r\n) {\r\n  return cues.map((item) => (item === target ? cloneCue(target, source) : item));\r\n}\r\n\r\nexport function getCurrentVideoCues(cues: MediaTrackCue[], duration: number) {\r\n  return cues.filter((item) => {\r\n    const { startTime, endTime } = item;\r\n\r\n    if (isNaN(endTime)) {\r\n      return startTime >= 0 && startTime <= duration;\r\n    } else {\r\n      return startTime >= 0 && startTime <= duration && endTime >= 0 && endTime <= duration;\r\n    }\r\n  });\r\n}\r\n\r\nexport function getSubtitleMarkerCues(cues: MediaTrackCue[], duration: number) {\r\n  return cues.filter((item) => {\r\n    const { startTime, endTime } = item;\r\n\r\n    if (isNaN(endTime)) {\r\n      return startTime >= 0 && startTime <= duration;\r\n    } else {\r\n      return startTime >= 0 && startTime <= duration && endTime >= 0;\r\n    }\r\n  });\r\n}\r\n\r\nexport function getCurrentCues(\r\n  type: MediaTrackTypes,\r\n  cues: MediaTrackCue[],\r\n  currentTime: number,\r\n  duration: number\r\n) {\r\n  const totalTime = currentTime + duration;\r\n\r\n  return cues.filter((item) => {\r\n    const { startTime, endTime } = item;\r\n\r\n    if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\r\n      return (\r\n        (startTime >= currentTime && startTime <= totalTime) ||\r\n        (endTime >= currentTime && endTime <= totalTime) ||\r\n        (startTime < currentTime && endTime > totalTime)\r\n      );\r\n    } else {\r\n      return startTime >= currentTime && startTime < totalTime;\r\n    }\r\n  });\r\n}\r\n\r\nexport function getCurrentCue(cues: MediaTrackCue[], currentTime: number) {\r\n  return cues.find((item, ind) => {\r\n    if (!item.action || item.action === MediaCueActions.ScrollVPauseC) {\r\n      return item.startTime <= currentTime && item.endTime > currentTime;\r\n    } else {\r\n      const next = cues[ind + 1];\r\n\r\n      return item.startTime <= currentTime && (!next || next.startTime > currentTime);\r\n    }\r\n  });\r\n}\r\n\r\nexport function validateCue(type: MediaTrackTypes, cues: MediaTrackCue[], cue: MediaTrackCue) {\r\n  const { startTime, endTime } = cue;\r\n  const index = cues.indexOf(cue);\r\n  const previous = cues[index - 1];\r\n\r\n  if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\r\n    return (\r\n      startTime >= 0 &&\r\n      endTime >= 0 &&\r\n      startTime < endTime &&\r\n      endTime - startTime > 0.2 &&\r\n      (!previous || previous.endTime < startTime)\r\n    );\r\n  } else {\r\n    return startTime >= 0 && (!previous || previous.startTime < startTime);\r\n  }\r\n}\r\n\r\nexport function findCueIndex(type: MediaTrackTypes, cues: MediaTrackCue[], currentTime: number) {\r\n  return cues.findIndex((cue, index) => {\r\n    const { startTime, endTime } = cue;\r\n    const next = cues[index + 1];\r\n\r\n    if (type === MediaTrackTypes.Subtitles || type === MediaTrackTypes.Labels) {\r\n      return (\r\n        (startTime <= currentTime && endTime > currentTime) ||\r\n        (currentTime >= endTime && (!next || currentTime < next.startTime))\r\n      );\r\n    } else {\r\n      return startTime <= currentTime && (!next || currentTime < next.startTime);\r\n    }\r\n  });\r\n}\r\n\r\nexport function validateCues(type: MediaTrackTypes, cues: MediaTrackCue[]) {\r\n  if (type === MediaTrackTypes.Contents) {\r\n    cues.forEach((cue) => {\r\n      if (!cue.content) {\r\n        throw new Error(\"Please select simple content\");\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport function normalizeMarkers(markers: MediaTrackCue[], duration: number) {\r\n  return markers.map((marker, ind) => {\r\n    const next = markers[ind + 1];\r\n\r\n    return { ...marker, endTime: next?.startTime ?? duration };\r\n  });\r\n}\r\n\r\nexport function convertTimeToXPos(time: number, pxPerSec: number, scrollTime = 0) {\r\n  return (time - scrollTime) * pxPerSec;\r\n}\r\n\r\nexport function convertXPosToTime(xPos: number, pxPerSec: number, scrollTime = 0) {\r\n  return xPos / pxPerSec + scrollTime;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}