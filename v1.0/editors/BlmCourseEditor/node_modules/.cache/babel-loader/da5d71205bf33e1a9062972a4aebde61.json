{"ast":null,"code":"import { toNumber } from \"./common\";\nexport function findIndex(arr, obj, key) {\n  const match = typeof obj === \"object\" ? obj[key] : obj;\n\n  if (arr) {\n    return arr.findIndex(item => {\n      return item[key] && item[key] === match;\n    });\n  }\n\n  return -1;\n}\nexport function findObject(arr, obj, key) {\n  const match = typeof obj === \"object\" ? obj[key] : obj;\n\n  if (arr) {\n    return arr.find(item => {\n      return item[key] && item[key] === match;\n    });\n  }\n\n  return undefined;\n}\nexport function deepCopy(obj) {\n  if (Array.isArray(obj)) {\n    return [...obj];\n  } else if (typeof obj === \"object\" && obj !== null) {\n    const result = { ...obj\n    };\n\n    for (let prop in result) {\n      const value = result[prop];\n      result[prop] = deepCopy(value);\n    }\n\n    return result;\n  }\n\n  return obj;\n}\nexport function addObject(arr, obj, index) {\n  const result = [...arr];\n  result.splice(index, 0, obj);\n  return result;\n}\nexport function updateIndex(arr, index, source) {\n  return arr.map((item, ind) => index === ind ? { ...item,\n    ...source\n  } : item);\n}\nexport function updateObject(arr, key, obj, newObj) {\n  const match = typeof obj === \"object\" ? obj[key] : obj;\n  return arr.map(item => item[key] === match ? { ...item,\n    ...newObj\n  } : item);\n}\nexport function updateObjectOf(arr, target, source) {\n  return arr.map(item => item === target ? { ...target,\n    ...source\n  } : item);\n}\nexport function reorderArray(arr, oldIndex, newIndex) {\n  const result = Array.from(arr);\n  const [removed] = result.splice(oldIndex, 1);\n  result.splice(newIndex, 0, removed);\n  return result;\n}\nexport function removeIndex(arr, index) {\n  const result = [...arr];\n  result.splice(index, 1);\n  return result;\n}\nexport function removeObject(arr, target) {\n  return arr.filter(item => item !== target);\n}\nexport function differenceOfObjects(source, target, key) {\n  return source.filter(item1 => !target.some(item2 => item1[key] === item2[key]));\n} //https://stackoverflow.com/questions/32609284/construct-flat-array-from-tree-of-objects\n\nexport function flatObject(obj, key) {\n  const arr = obj[key];\n\n  if (Array.isArray(arr)) {\n    return Array.prototype.concat.apply(arr, arr.map(item => flatObject(item, key)));\n  }\n\n  return [];\n}\nexport function filterFalsy(arr) {\n  return arr.filter(val => val !== undefined && val !== null ? true : false);\n}\nexport function filterDuplicates(arr) {\n  return Array.from(new Set(arr));\n}\nexport function getMaxValue(arr, key) {\n  return arr.reduce((prev, item) => {\n    const value = item[key] || 0;\n    return Math.max(prev, typeof value === \"number\" ? value : toNumber(value));\n  }, 0);\n}\nexport function getObjectKey(obj, arr, def) {\n  var _Object$values$find;\n\n  return (_Object$values$find = Object.values(obj).find(value => arr.contains(value))) !== null && _Object$values$find !== void 0 ? _Object$values$find : def;\n}","map":{"version":3,"sources":["C:/Users/Rajesh/Downloads/bilim (2)/bilim/v1.0/editors/BlmCourseEditor/src/utils/core/array.ts"],"names":["toNumber","findIndex","arr","obj","key","match","item","findObject","find","undefined","deepCopy","Array","isArray","result","prop","value","addObject","index","splice","updateIndex","source","map","ind","updateObject","newObj","updateObjectOf","target","reorderArray","oldIndex","newIndex","from","removed","removeIndex","removeObject","filter","differenceOfObjects","item1","some","item2","flatObject","prototype","concat","apply","filterFalsy","val","filterDuplicates","Set","getMaxValue","reduce","prev","Math","max","getObjectKey","def","Object","values","contains"],"mappings":"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","sourcesContent":["import { KeysOfType } from \"types\";\r\nimport { toNumber } from \"./common\";\r\n\r\nexport function findIndex<T extends object, K extends keyof T>(arr: T[], obj: T | T[K], key: K) {\r\n  const match = typeof obj === \"object\" ? (obj as T)[key] : obj;\r\n\r\n  if (arr) {\r\n    return arr.findIndex((item) => {\r\n      return item[key] && item[key] === match;\r\n    });\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function findObject<T extends object, K extends keyof T>(\r\n  arr: T[],\r\n  obj: T | T[K],\r\n  key: K\r\n): T | undefined {\r\n  const match = typeof obj === \"object\" ? (obj as T)[key] : obj;\r\n\r\n  if (arr) {\r\n    return arr.find((item) => {\r\n      return item[key] && item[key] === match;\r\n    });\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function deepCopy<T>(obj: T): T {\r\n  if (Array.isArray(obj)) {\r\n    return [...obj] as any;\r\n  } else if (typeof obj === \"object\" && obj !== null) {\r\n    const result = { ...obj };\r\n\r\n    for (let prop in result) {\r\n      const value = result[prop];\r\n\r\n      result[prop] = deepCopy(value);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nexport function addObject<T>(arr: T[], obj: T, index: number) {\r\n  const result = [...arr];\r\n\r\n  result.splice(index, 0, obj);\r\n\r\n  return result;\r\n}\r\n\r\nexport function updateIndex<T extends object>(arr: T[], index: number, source: Partial<T>) {\r\n  return arr.map((item, ind) =>\r\n    index === ind\r\n      ? {\r\n          ...item,\r\n          ...source,\r\n        }\r\n      : item\r\n  );\r\n}\r\n\r\nexport function updateObject<T extends object, K extends keyof T>(\r\n  arr: T[],\r\n  key: K,\r\n  obj: T | T[K],\r\n  newObj: Partial<T>\r\n) {\r\n  const match = typeof obj === \"object\" ? (obj as T)[key] : obj;\r\n\r\n  return arr.map((item) =>\r\n    item[key] === match\r\n      ? {\r\n          ...item,\r\n          ...newObj,\r\n        }\r\n      : item\r\n  );\r\n}\r\n\r\nexport function updateObjectOf<T extends object>(arr: T[], target: T, source: Partial<T>) {\r\n  return arr.map((item) => (item === target ? { ...target, ...source } : item));\r\n}\r\n\r\nexport function reorderArray<T>(arr: T[], oldIndex: number, newIndex: number) {\r\n  const result = Array.from(arr);\r\n  const [removed] = result.splice(oldIndex, 1);\r\n\r\n  result.splice(newIndex, 0, removed);\r\n\r\n  return result;\r\n}\r\n\r\nexport function removeIndex<T>(arr: T[], index: number) {\r\n  const result = [...arr];\r\n\r\n  result.splice(index, 1);\r\n\r\n  return result;\r\n}\r\n\r\nexport function removeObject<T>(arr: T[], target: T) {\r\n  return arr.filter((item) => item !== target);\r\n}\r\n\r\nexport function differenceOfObjects<T extends object>(source: T[], target: T[], key: keyof T) {\r\n  return source.filter((item1) => !target.some((item2) => item1[key] === item2[key]));\r\n}\r\n\r\n//https://stackoverflow.com/questions/32609284/construct-flat-array-from-tree-of-objects\r\nexport function flatObject<T>(obj: T, key: KeysOfType<T, Array<any>>): T[] {\r\n  const arr = obj[key];\r\n\r\n  if (Array.isArray(arr)) {\r\n    return Array.prototype.concat.apply(\r\n      arr,\r\n      arr.map((item) => flatObject(item, key))\r\n    );\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\nexport function filterFalsy<T>(arr: (T | undefined | null)[]) {\r\n  return arr.filter((val) => (val !== undefined && val !== null ? true : false)) as T[];\r\n}\r\n\r\nexport function filterDuplicates<T>(arr: T[]) {\r\n  return Array.from(new Set(arr));\r\n}\r\n\r\nexport function getMaxValue<T extends Partial<Record<K, string | number>>, K extends keyof T>(\r\n  arr: T[],\r\n  key: K\r\n) {\r\n  return arr.reduce((prev, item) => {\r\n    const value = item[key] || 0;\r\n\r\n    return Math.max(prev, typeof value === \"number\" ? value : toNumber(value as string));\r\n  }, 0);\r\n}\r\n\r\nexport function getObjectKey<T extends string>(\r\n  obj: { [s: string]: T },\r\n  arr: DOMTokenList,\r\n  def: T\r\n): T;\r\nexport function getObjectKey<T extends string>(\r\n  obj: { [s: string]: T },\r\n  arr: DOMTokenList\r\n): T | undefined;\r\nexport function getObjectKey<T extends string>(\r\n  obj: { [s: string]: T },\r\n  arr: DOMTokenList,\r\n  def?: T\r\n): T | undefined {\r\n  return Object.values(obj).find((value) => arr.contains(value)) ?? def;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}